# superoptimizer-GrifH
Admittedly, I am not sure I hit the scope on what I should have accomplished in the allocated time for this project. After getting through the reading, and reading through the aha code, I didn't make really any contributions, though some of that can be chalked up to getting used to C/Assembly again. Regardless, I do think that that I made some interesting observations. For one, some of the test files I put in tried the optimizer with functions that probably should have been 2 instruction operations such as squaring and doubling, both did not find any solutions. Unless I am missing something big, that is a gap in the code somewhere, although 3 is a very good result as well. Also from a performance standpoint, it was interesting that the better solutions you asked for, (less instructions) the worse performance is. Granted, that is considering the problem as how many solutions can you find, as normally cutting off after a few solutions would be fine for higher amounts of instructions. This also emphasizes something mentioned int he readings in that this really only works for small portions of code. Conceptually, at least with this as the base algorithm, optimizing further will be tough. Another alternate idea that came to my mind would be trying some sort of tree, as it would allow better pruning opportunites. Overall though, I thought it showed remarkable runtimes, and it makes sense that a compiler performing operations like this over many small portions would create meaningful permormance imporovements.
